name: _lib | Promote via PR (GitOps)

on:
  workflow_call:
    inputs:
      service_name:
        required: true
        type: string

      target_env:
        description: "dev / staging / prod"
        required: true
        type: string

      source_values_file:
        description: "Path to source env values file (optional, if new_tag not set)"
        required: false
        type: string
        default: ""

      target_values_file:
        description: "Path to target env values file"
        required: true
        type: string

      new_tag:
        description: "If set, use this tag instead of reading from source_values_file"
        required: false
        type: string
        default: ""

      new_digest:
        description: "If set, also update digest in target_values_file"
        required: false
        type: string
        default: ""

      base_branch:
        required: false
        type: string
        default: "main"

      pr_branch_prefix:
        required: false
        type: string
        default: "promote"

      pr_labels:
        description: "Comma separated labels"
        required: false
        type: string
        default: "promotion,gitops"

      skip_if_exists:
        description: "If true, do nothing when a promote PR already exists"
        required: false
        type: boolean
        default: true

jobs:
  promote:
    name: "${{ inputs.service_name }} | Promote to ${{ inputs.target_env }}"
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.base_branch }}

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Resolve tags (source -> target)
        id: tags
        run: |
          set -e

          SRC_FILE="${{ inputs.source_values_file }}"
          TGT_FILE="${{ inputs.target_values_file }}"

          if [ ! -f "$TGT_FILE" ]; then
            echo "Target values file not found: $TGT_FILE"
            exit 1
          fi

          # Read current target tag
          TGT_TAG="$(grep -E '^[[:space:]]*tag:[[:space:]]*' "$TGT_FILE" | head -n1 | sed -E 's/^[[:space:]]*tag:[[:space:]]*//')"
          if [ -z "$TGT_TAG" ]; then
            echo "Cannot find 'tag:' in target file: $TGT_FILE"
            exit 1
          fi

          # Decide new tag:
          # 1) if new_tag input provided -> use it
          # 2) else read from source_values_file
          if [ -n "${{ inputs.new_tag }}" ]; then
            NEW_TAG="${{ inputs.new_tag }}"
          else
            if [ -z "$SRC_FILE" ]; then
              echo "Either new_tag or source_values_file must be provided."
              exit 1
            fi
            if [ ! -f "$SRC_FILE" ]; then
              echo "Source values file not found: $SRC_FILE"
              exit 1
            fi
            NEW_TAG="$(grep -E '^[[:space:]]*tag:[[:space:]]*' "$SRC_FILE" | head -n1 | sed -E 's/^[[:space:]]*tag:[[:space:]]*//')"
            if [ -z "$NEW_TAG" ]; then
              echo "Cannot find 'tag:' in source file: $SRC_FILE"
              exit 1
            fi
          fi

          echo "Current target tag: $TGT_TAG"
          echo "New desired tag:   $NEW_TAG"

          echo "target_tag=$TGT_TAG" >> $GITHUB_OUTPUT
          echo "new_tag=$NEW_TAG" >> $GITHUB_OUTPUT

      - name: Stop (already up to date)
        if: ${{ steps.tags.outputs.target_tag == steps.tags.outputs.new_tag }}
        run: |
          echo "✅ Target is already up-to-date: ${{ steps.tags.outputs.new_tag }}"
          exit 0

      - name: Determine branch name
        id: bn
        run: |
          set -e
          BR="${{ inputs.pr_branch_prefix }}/${{ inputs.service_name }}/${{ inputs.target_env }}/${{ steps.tags.outputs.new_tag }}"
          BR="$(echo "$BR" | tr ' ' '-' | tr ':' '-')"
          echo "branch=$BR" >> $GITHUB_OUTPUT

      - name: Check existing open PR
        if: ${{ inputs.skip_if_exists }}
        id: prcheck
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const head = `${owner}:${{ steps.bn.outputs.branch }}`;
            const prs = await github.rest.pulls.list({ owner, repo, state: "open", head });
            core.setOutput("exists", prs.data.length > 0 ? "true" : "false");

      - name: Stop (PR already exists)
        if: ${{ inputs.skip_if_exists && steps.prcheck.outputs.exists == 'true' }}
        run: |
          echo "✅ Promotion PR already exists for branch: ${{ steps.bn.outputs.branch }}"
          exit 0

      - name: Create branch
        run: |
          git checkout -b "${{ steps.bn.outputs.branch }}"

      - name: Update target values file (image.tag + optional image.digest)
        run: |
          set -e
          FILE="${{ inputs.target_values_file }}"

          if [ ! -f "$FILE" ]; then
            echo "Target values file not found: $FILE"
            exit 1
          fi

          echo "Updating $FILE -> tag: ${{ steps.tags.outputs.new_tag }}"
          sed -i.bak -E "s/^([[:space:]]*tag:[[:space:]]*).*/\\1${{ steps.tags.outputs.new_tag }}/" "$FILE"

          if [ -n "${{ inputs.new_digest }}" ]; then
            echo "Updating $FILE -> digest: ${{ inputs.new_digest }}"
            if grep -qE "^[[:space:]]*digest:[[:space:]]*" "$FILE"; then
              sed -i.bak -E "s/^([[:space:]]*digest:[[:space:]]*).*/\\1\"${{ inputs.new_digest }}\"/" "$FILE"
            else
              awk -v dg="${{ inputs.new_digest }}" '
                {print}
                $0 ~ /^[[:space:]]*tag:[[:space:]]*/ && !done {
                  print "  digest: \"" dg "\""
                  done=1
                }
              ' "$FILE" > "$FILE.tmp" && mv "$FILE.tmp" "$FILE"
            fi
          fi

          rm -f "$FILE.bak"

          echo "Result:"
          grep -nE "^[[:space:]]*(tag|digest):" "$FILE" || true

      - name: Commit changes
        run: |
          set -e
          git add "${{ inputs.target_values_file }}"
          git commit -m "promote(${{ inputs.service_name }}): ${{ inputs.target_env }} -> ${{ steps.tags.outputs.new_tag }}"

      - name: Push branch
        run: |
          git push -u origin "${{ steps.bn.outputs.branch }}"

      - name: Create PR
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const title = `Promote ${{ inputs.service_name }} to ${{ inputs.target_env }}: ${{ steps.tags.outputs.new_tag }}`;
            const body = [
              `This is an automated GitOps promotion PR.`,
              ``,
              `- Service: **${{ inputs.service_name }}**`,
              `- Target env: **${{ inputs.target_env }}**`,
              `- New image tag: **${{ steps.tags.outputs.new_tag }}**`,
              `${{ inputs.new_digest != '' && format('- New image digest: **{0}**', inputs.new_digest) || '' }}`,
              `- Target values: \`${{ inputs.target_values_file }}\``,
              `${{ inputs.source_values_file != '' && format('- Source values: `{0}`', inputs.source_values_file) || '' }}`
            ].filter(Boolean).join("\n");

            const pr = await github.rest.pulls.create({
              owner, repo,
              title,
              head: "${{ steps.bn.outputs.branch }}",
              base: "${{ inputs.base_branch }}",
              body
            });

            const labels = "${{ inputs.pr_labels }}".split(",").map(s => s.trim()).filter(Boolean);
            if (labels.length) {
              await github.rest.issues.addLabels({
                owner, repo,
                issue_number: pr.data.number,
                labels
              });
            }